
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>morebs2.poly_interpolation &#8212; morebs 0.0.3 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for morebs2.poly_interpolation</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span> <span class="k">as</span> <span class="n">opt</span>
<span class="kn">from</span> <span class="nn">.random_generators</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.travel_data</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">powerRow</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span> <span class="o">**</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">l</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>

<span class="c1"># the effect of gravity at any instant, used to calculate acceleration</span>
<span class="n">GRAVITY_AT_INSTANT</span> <span class="o">=</span> <span class="mi">11</span>

<div class="viewcode-block" id="LagrangePolySolver"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver">[docs]</a><span class="k">class</span> <span class="nc">LagrangePolySolver</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    basic polynomial solver by Lagrange basis functions</span>

<span class="sd">    polynomial solver class that finds an interpolating function for a set of</span>
<span class="sd">    2-dimensional points.</span>

<span class="sd">    :class:`LagrangePolySolver` also has the capability to calculate information concerning</span>
<span class="sd">    the curve such as velocity data (using an initial velocity) by the gravity variable `GRAVITY_AT_INSTANT`,</span>
<span class="sd">    in which it collates that information into :class:`TravelData` instances.</span>

<span class="sd">    :param points: sequence of n-dimensional points</span>
<span class="sd">    :param prefetch: perform pre-processing (x-bounds and integral length) on points?</span>
<span class="sd">    :type prefetch: bool</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">prefetch</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ps</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vfs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">recentRangeSearchInfo</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrl</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">prefetch</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prefetch_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timeActionStamp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">allTravelData</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1"># type TravelData</span>
            <span class="c1"># variables used to declare allTravelData</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocityData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durationData</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">#</span>
<div class="viewcode-block" id="LagrangePolySolver.yield_lines_clockwise_from_source_in_area"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.yield_lines_clockwise_from_source_in_area">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">yield_lines_clockwise_from_source_in_area</span><span class="p">(</span><span class="n">sourcePoint</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">numParts</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">is_valid_area</span><span class="p">(</span><span class="n">area</span><span class="p">),</span> <span class="s2">&quot;invalid area&quot;</span>

        <span class="c1"># check that source point is a corner of area</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">quadrant_of_corner_point_in_area</span><span class="p">(</span><span class="n">sourcePoint</span><span class="p">,</span> <span class="n">area</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">dRange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">dRange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">q</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dRange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">180</span><span class="p">,</span><span class="mi">270</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dRange</span> <span class="o">=</span> <span class="p">[</span><span class="mi">270</span><span class="p">,</span><span class="mi">360</span><span class="p">]</span>

        <span class="n">degDelta</span> <span class="o">=</span> <span class="mf">90.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">numParts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">xLength</span> <span class="o">=</span> <span class="n">area</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">area</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">yLength</span> <span class="o">=</span> <span class="n">area</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">area</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">maxLength</span> <span class="o">=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">area</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">area</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numParts</span><span class="p">):</span>
            <span class="n">deg</span> <span class="o">=</span> <span class="n">dRange</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">degDelta</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">generate_line_by_length_and_angle</span><span class="p">(</span><span class="n">sourcePoint</span><span class="p">,</span> <span class="n">maxLength</span><span class="p">,</span> <span class="n">deg</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">l</span><span class="o">.</span><span class="n">trim_to_fit_in_area</span><span class="p">(</span><span class="n">area</span><span class="p">)</span></div>

<div class="viewcode-block" id="LagrangePolySolver.prefetch_data"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.prefetch_data">[docs]</a>    <span class="k">def</span> <span class="nf">prefetch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds_for_x</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integral_length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span> <span class="n">integrationHop</span> <span class="o">=</span> <span class="n">DEFAULT_TRAVELLING_HOP</span><span class="p">)</span></div>

<div class="viewcode-block" id="LagrangePolySolver.display_basic"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.display_basic">[docs]</a>    <span class="k">def</span> <span class="nf">display_basic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">* min: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">* max: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">* points: &quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">* target range points: &quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">* integral: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrl</span><span class="p">)</span></div>

    <span class="c1">########################################## START: lagrange basis</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TODO: opt., make lambda function instead??</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.lagrange_basis"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.lagrange_basis">[docs]</a>    <span class="k">def</span> <span class="nf">lagrange_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">pointIndex</span><span class="p">):</span>
        <span class="n">v</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">pointIndex</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">num</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">den</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[</span><span class="n">pointIndex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">den</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#return 0</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NOT GOOD: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[</span><span class="n">pointIndex</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot; X2 &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1">#v = 0</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">zero_div</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="n">den</span><span class="p">),</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span></div>

<div class="viewcode-block" id="LagrangePolySolver.bounds_for_x"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.bounds_for_x">[docs]</a>    <span class="k">def</span> <span class="nf">bounds_for_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">returnType</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">returnType</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span>

        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">))</span></div>

<div class="viewcode-block" id="LagrangePolySolver.output_by_lagrange_basis"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.output_by_lagrange_basis">[docs]</a>    <span class="k">def</span> <span class="nf">output_by_lagrange_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="c1"># CASE: x is 0-length</span>
        <span class="c1">##if self.</span>

        <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">)):</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagrange_basis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">y</span></div>

    <span class="c1"># TODO: this needs to be fixed for missed hop at end</span>
<div class="viewcode-block" id="LagrangePolySolver.output_range"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.output_range">[docs]</a>    <span class="k">def</span> <span class="nf">output_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rangeX</span><span class="p">,</span> <span class="n">intRound</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">rangeX</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rangeX</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">i</span><span class="p">)]])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">intRound</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">targetRangePoints</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>

    <span class="c1">########################################## END: lagrange basis</span>

<div class="viewcode-block" id="LagrangePolySolver.x_point_exists"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.x_point_exists">[docs]</a>    <span class="k">def</span> <span class="nf">x_point_exists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">q</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

    <span class="c1"># TODO: code and refactor, multi-processing</span>
<div class="viewcode-block" id="LagrangePolySolver.integral_length"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.integral_length">[docs]</a>    <span class="k">def</span> <span class="nf">integral_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startX</span><span class="p">,</span> <span class="n">endX</span><span class="p">,</span> <span class="n">integrationHop</span> <span class="o">=</span> <span class="n">DEFAULT_TRAVELLING_HOP</span><span class="p">):</span>
        <span class="c1"># TODO: off-by-1 bug here</span>
        <span class="k">assert</span> <span class="n">integrationHop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;invalid integration hop&quot;</span>
        <span class="n">integrationHop</span> <span class="o">=</span> <span class="n">integrationHop</span> <span class="k">if</span> <span class="n">startX</span> <span class="o">&lt;</span> <span class="n">endX</span> <span class="k">else</span> <span class="o">-</span><span class="n">integrationHop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrl</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">prevPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">startX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">startX</span><span class="p">))</span>

        <span class="n">integrationHop</span>
        <span class="n">tFunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">endX</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">startX</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">tFunc</span><span class="p">(</span><span class="n">startX</span><span class="p">):</span>
            <span class="n">startX</span> <span class="o">+=</span> <span class="n">integrationHop</span>
            <span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="n">startX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">startX</span><span class="p">))</span>
            <span class="n">d</span> <span class="o">+=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
            <span class="n">prevPoint</span> <span class="o">=</span> <span class="n">point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrl</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">return</span> <span class="n">d</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return:</span>
<span class="sd">    - (end point)::(2-tuple)</span>
<span class="sd">    - (distance travelled)::(float)</span>
<span class="sd">    - (&gt;= wanted distance)::(bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.get_xrange_for_wanted_distance"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.get_xrange_for_wanted_distance">[docs]</a>    <span class="k">def</span> <span class="nf">get_xrange_for_wanted_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startPoint</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">integrationHop</span> <span class="o">=</span> <span class="n">DEFAULT_TRAVELLING_HOP</span><span class="p">):</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">distance</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;invalid wanted distance&quot;</span>

        <span class="n">pf</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">df</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">distance</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">gw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traversal_loop</span><span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">integrationHop</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>

        <span class="c1"># trim leftovers</span>
        <span class="k">if</span> <span class="n">gw</span><span class="p">:</span>
            <span class="n">newHop</span> <span class="o">=</span> <span class="n">integrationHop</span> <span class="o">/</span> <span class="mf">10.0</span>
            <span class="n">excess</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">distance</span>
            <span class="n">prevPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">integrationHop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">integrationHop</span><span class="p">))</span>
            <span class="n">dPrev</span> <span class="o">=</span> <span class="n">q</span> <span class="o">-</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">prevPoint</span><span class="p">)</span>
            <span class="n">wanted</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">-</span> <span class="n">dPrev</span>

            <span class="n">df2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">wanted</span> <span class="k">else</span> <span class="kc">False</span>
            <span class="n">r2</span><span class="p">,</span> <span class="n">q2</span><span class="p">,</span> <span class="n">gw2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traversal_loop</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">integrationHop</span><span class="p">,</span> <span class="n">newHop</span><span class="p">,</span> <span class="n">pf</span><span class="p">,</span> <span class="n">df2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r2</span><span class="p">,</span> <span class="n">dPrev</span> <span class="o">+</span> <span class="n">q2</span><span class="p">,</span> <span class="n">gw2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">gw</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    arguments:</span>
<span class="sd">    - startPoint: float, x-value</span>
<span class="sd">    - integrationHop: float, +|-</span>
<span class="sd">    - pFunc: function(float), point termination</span>
<span class="sd">    - dFunc: function(float), distance termination</span>

<span class="sd">    return:</span>
<span class="sd">    - (end point)::(2-tuple)</span>
<span class="sd">    - (distance travelled)::(float)</span>
<span class="sd">    - (&gt;= wanted distance)::(bool)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.traversal_loop"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.traversal_loop">[docs]</a>    <span class="k">def</span> <span class="nf">traversal_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startPoint</span><span class="p">,</span> <span class="n">integrationHop</span><span class="p">,</span> <span class="n">pFunc</span><span class="p">,</span> <span class="n">dFunc</span><span class="p">):</span>
        <span class="n">prevPoint</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">startPoint</span><span class="p">)),</span>\
                    <span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">startPoint</span><span class="p">))</span>
        <span class="n">totalPd</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">totalPd_</span> <span class="o">=</span> <span class="n">totalPd</span>
        <span class="n">gotWanted</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># TODO: find the cause of bug and delete fix</span>
        <span class="n">noChange</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">pFunc</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">prevPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">integrationHop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">integrationHop</span><span class="p">))</span>
            <span class="n">totalPd_</span> <span class="o">=</span> <span class="n">totalPd</span>
            <span class="n">totalPd</span> <span class="o">+=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dFunc</span><span class="p">(</span><span class="n">totalPd</span><span class="p">):</span>
                <span class="n">gotWanted</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">):</span>
                <span class="n">noChange</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">noChange</span> <span class="o">&gt;=</span><span class="mi">100</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n\t</span><span class="s2">NO CHANGE</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">noChange</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">prevPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="ow">or</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">:</span>
            <span class="n">prevPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">prevPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">integrationHop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">integrationHop</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">prevPoint</span><span class="p">,</span> <span class="n">totalPd_</span><span class="p">,</span> <span class="n">gotWanted</span>
        <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">totalPd</span><span class="p">,</span> <span class="n">gotWanted</span></div>

<div class="viewcode-block" id="LagrangePolySolver.average_slope_on_range"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.average_slope_on_range">[docs]</a>    <span class="k">def</span> <span class="nf">average_slope_on_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startX</span><span class="p">,</span> <span class="n">endX</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">startX</span> <span class="o">&lt;</span> <span class="n">endX</span><span class="p">,</span> <span class="s2">&quot;invalid start and end x points&quot;</span>

        <span class="n">prevPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">startX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">startX</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># TODO: refactor this to #$#</span>
        <span class="k">while</span> <span class="n">startX</span> <span class="o">&lt;</span> <span class="n">endX</span><span class="p">:</span>
            <span class="n">startX</span> <span class="o">+=</span> <span class="n">integrationHop</span>
            <span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="n">startX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">startX</span><span class="p">))</span>
            <span class="n">d</span> <span class="o">+=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
            <span class="n">prevPoint</span> <span class="o">=</span> <span class="n">point</span>
        <span class="k">return</span> <span class="n">d</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">endX</span> <span class="o">-</span> <span class="n">startX</span><span class="p">)</span></div>

    <span class="c1">########################### START: vector-form solution</span>

<div class="viewcode-block" id="LagrangePolySolver.get_vfs_vars"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.get_vfs_vars">[docs]</a>    <span class="k">def</span> <span class="nf">get_vfs_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># form A</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">powerRow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>

        <span class="c1"># form b</span>
        <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">ys</span></div>

<div class="viewcode-block" id="LagrangePolySolver.vector_form_solution"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.vector_form_solution">[docs]</a>    <span class="k">def</span> <span class="nf">vector_form_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vfs_vars</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span></div>

<div class="viewcode-block" id="LagrangePolySolver.output_by_vector_form"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.output_by_vector_form">[docs]</a>    <span class="k">def</span> <span class="nf">output_by_vector_form</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">powerRow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">q</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vfs</span><span class="p">)</span></div>

<div class="viewcode-block" id="LagrangePolySolver.distance_between_points"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.distance_between_points">[docs]</a>    <span class="k">def</span> <span class="nf">distance_between_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>

        <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    description:</span>
<span class="sd">    - draws a line between two polynomial points and determines the minumum velocity to travel.</span>

<span class="sd">      CAUTION: does not consider points in (min(x1,x2), max(x1,x2))</span>

<span class="sd">    arguments:</span>
<span class="sd">    - x1: float</span>
<span class="sd">    - x2: float</span>

<span class="sd">    return:</span>
<span class="sd">    -</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.required_velocity_for_travel_of_range_angle_effect"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.required_velocity_for_travel_of_range_angle_effect">[docs]</a>    <span class="k">def</span> <span class="nf">required_velocity_for_travel_of_range_angle_effect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>

        <span class="n">p1</span><span class="p">,</span><span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">x1</span><span class="p">)),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span>
        <span class="n">acc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceleration_between_points</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">acc</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">acc</span> <span class="o">*</span> <span class="n">d</span>
        <span class="n">accTotal</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
        <span class="n">duration</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">accTotal</span> <span class="o">/</span> <span class="n">acc</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span> <span class="o">/</span> <span class="n">duration</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    description:</span>
<span class="sd">    - uses above method, considers all points in range by hop increment</span>

<span class="sd">    return:</span>
<span class="sd">    - float</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.required_velocity_for_travel_of_range_angle_effect_by_hop"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.required_velocity_for_travel_of_range_angle_effect_by_hop">[docs]</a>    <span class="k">def</span> <span class="nf">required_velocity_for_travel_of_range_angle_effect_by_hop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">hop</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">hop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;hop must be greater than 0&quot;</span>
        <span class="k">assert</span> <span class="n">x1</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="ow">and</span> <span class="n">x1</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span> <span class="s2">&quot;invalid arg [0]&quot;</span>
        <span class="k">assert</span> <span class="n">x2</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="ow">and</span> <span class="n">x2</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span> <span class="s2">&quot;invalid arg [1]&quot;</span>

        <span class="n">hop</span> <span class="o">=</span> <span class="o">-</span><span class="n">hop</span> <span class="k">if</span> <span class="n">x2</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="k">else</span> <span class="n">hop</span>
        <span class="n">q1</span> <span class="o">=</span> <span class="n">x2</span>
        <span class="n">q2</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">hop</span>
        <span class="n">tfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="n">vmin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">while</span> <span class="n">tfunc</span><span class="p">(</span><span class="n">q2</span><span class="p">):</span>
            <span class="n">p1</span><span class="p">,</span><span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">q2</span><span class="p">)),</span> <span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">q1</span><span class="p">))</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">back_hop_for_velocity</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">vmin</span><span class="p">)</span>
            <span class="n">q1</span> <span class="o">=</span> <span class="n">q2</span>
            <span class="n">q2</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">q2</span> <span class="o">+</span> <span class="n">hop</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vmin</span></div>

<div class="viewcode-block" id="LagrangePolySolver.back_hop_for_velocity"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.back_hop_for_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">back_hop_for_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">velocity</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceleration_between_points</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="n">velocity</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>
        <span class="n">soln</span><span class="p">,</span> <span class="n">stat</span> <span class="o">=</span> <span class="n">quadratic_formula_solve_for_reals</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

        <span class="c1"># case: pos. accel.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stat</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">velocity</span> <span class="o">-</span> <span class="n">a</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">soln</span><span class="p">)</span></div>

<div class="viewcode-block" id="LagrangePolySolver.is_travel_over_range_feasible"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.is_travel_over_range_feasible">[docs]</a>    <span class="k">def</span> <span class="nf">is_travel_over_range_feasible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">hop</span><span class="p">,</span> <span class="n">velocity</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">required_velocity_for_travel_of_range_angle_effect_by_hop</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">hop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">velocity</span> <span class="o">&gt;=</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="LagrangePolySolver.acceleration_between_points"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.acceleration_between_points">[docs]</a>    <span class="k">def</span> <span class="nf">acceleration_between_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="k">return</span> <span class="mi">0</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">angle_between_two_points</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
        <span class="n">prop</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="mf">90.0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GRAVITY_AT_INSTANT</span> <span class="o">*</span> <span class="n">prop</span></div>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    travel time == 1 if dist(x1,x2) == bv and ang(x1,x2) == 0</span>
<span class="sd">    &#39;&#39;&#39;</span>
<div class="viewcode-block" id="LagrangePolySolver.velocity_between_points_by_angle_effect"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.velocity_between_points_by_angle_effect">[docs]</a>    <span class="k">def</span> <span class="nf">velocity_between_points_by_angle_effect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">baselineVelocity</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">baselineVelocity</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceleration_between_points</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span></div>

    <span class="c1"># TODO: needs to be tested.</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    description:</span>
<span class="sd">    -</span>

<span class="sd">    return:</span>
<span class="sd">    - (current velocity)::float</span>
<span class="sd">    - (able to travel)::bool</span>
<span class="sd">    - (duration)::float</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.velocity_and_duration_between_points_by_angle_effect"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.velocity_and_duration_between_points_by_angle_effect">[docs]</a>    <span class="k">def</span> <span class="nf">velocity_and_duration_between_points_by_angle_effect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="n">duration</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>

        <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">baselineVelocity</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span> <span class="k">return</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">duration</span>

        <span class="c1"># TODO: refactor below equality statement</span>
        <span class="k">if</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">duration</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span>

        <span class="c1"># case: acceleration will be divided</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;=</span> <span class="n">baselineVelocity</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceleration_between_points</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">baselineVelocity</span>
            <span class="k">return</span> <span class="n">baselineVelocity</span> <span class="o">+</span> <span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">duration</span> <span class="o">+</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">baselineVelocity</span>
        <span class="k">else</span><span class="p">:</span>
        <span class="c1"># case: travel time b/t points &gt; 1 unit</span>
            <span class="n">x1_</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xrange_for_wanted_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="n">DEFAULT_TRAVELLING_HOP</span> <span class="k">if</span> <span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="o">-</span><span class="n">DEFAULT_TRAVELLING_HOP</span><span class="p">)</span>
            <span class="n">baselineVelocity</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">acceleration_between_points</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1_</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">equal_iterables</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x1_</span><span class="p">,</span> <span class="n">roundPlaces</span> <span class="o">=</span> <span class="mi">5</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">duration</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_and_duration_between_points_by_angle_effect</span><span class="p">(</span><span class="n">x1_</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="n">duration</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="LagrangePolySolver.travel_time_between_points"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.travel_time_between_points">[docs]</a>    <span class="k">def</span> <span class="nf">travel_time_between_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">velocity</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="n">x2</span><span class="p">)</span> <span class="o">/</span> <span class="n">velocity</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    arguments:</span>
<span class="sd">    - startX: float, x-value</span>
<span class="sd">    - duration: float, &gt;= 0</span>
<span class="sd">    - baselineVelocity: float, &gt;=</span>
<span class="sd">    - hop: float, small</span>

<span class="sd">    return:</span>
<span class="sd">    - TravelData, (halt restricted)::bool, (bounds reached)::bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.travel_from_start_for_duration_under_angle_effect"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.travel_from_start_for_duration_under_angle_effect">[docs]</a>    <span class="k">def</span> <span class="nf">travel_from_start_for_duration_under_angle_effect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startX</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="n">hop</span><span class="p">):</span>
        <span class="c1"># neg</span>
        <span class="k">if</span> <span class="n">hop</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="c1"># non-neg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">baselineVelocity</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">CANNOT TRAVEL ANYMORE&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span>

        <span class="n">rfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">continue_travelling</span>
        <span class="n">tfunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">duration</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">dur</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">prevPoint</span> <span class="o">=</span> <span class="p">(</span><span class="n">startX</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">startX</span><span class="p">))</span>
        <span class="n">max100</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">allPoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">prevPoint</span><span class="p">]</span>

        <span class="c1"># travel for duration</span>
        <span class="n">endPoint</span><span class="p">,</span> <span class="n">allPoints</span><span class="p">,</span> <span class="n">dur</span><span class="p">,</span> <span class="n">baselineVelocity1</span><span class="p">,</span> <span class="n">numHops</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_travel_loop</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">,</span> <span class="n">allPoints</span><span class="p">,</span> <span class="n">rfunc</span><span class="p">,</span> <span class="n">tfunc</span><span class="p">,</span> <span class="n">hop</span><span class="p">,</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="n">dur</span><span class="p">,</span> <span class="s2">&quot;travel time history&quot;</span><span class="p">)</span>
        <span class="n">hopRanges</span> <span class="o">=</span> <span class="p">[((</span><span class="mi">0</span><span class="p">,</span> <span class="n">numHops</span><span class="p">),</span> <span class="n">hop</span><span class="p">)]</span>

        <span class="c1"># case: out-of-bounds, cut off leftovers</span>
        <span class="k">if</span> <span class="n">stat</span> <span class="ow">or</span> <span class="n">haltRestricted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">timeActionStamp</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">TravelData</span><span class="p">(</span><span class="n">idn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeActionStamp</span><span class="p">,</span> <span class="n">pointData</span> <span class="o">=</span> <span class="n">allPoints</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">durationData</span> <span class="o">=</span> <span class="n">dur</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">velocityData</span> <span class="o">=</span> <span class="n">baselineVelocity1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">hopRanges</span> <span class="o">=</span> <span class="n">hopRanges</span><span class="p">),</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="n">stat</span>

        <span class="c1"># run another travel loop for remainders</span>
        <span class="n">leftovers</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dur</span><span class="p">)</span> <span class="o">-</span> <span class="n">duration</span>
        <span class="n">newWantedDuration</span> <span class="o">=</span> <span class="n">dur</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">leftovers</span>

        <span class="n">newHop</span> <span class="o">=</span> <span class="n">hop</span> <span class="o">/</span> <span class="mf">10.0</span>
        <span class="n">prevPoint</span> <span class="o">=</span> <span class="n">allPoints</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">newTFunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">newWantedDuration</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">bulkDuration</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dur</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">bv</span> <span class="o">=</span> <span class="n">baselineVelocity1</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">baselineVelocity1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">baselineVelocity</span>
        <span class="n">endPoint</span><span class="p">,</span> <span class="n">allPoints2</span><span class="p">,</span> <span class="n">dur2</span><span class="p">,</span> <span class="n">baselineVelocity2</span><span class="p">,</span> <span class="n">numHops2</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_travel_loop</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">,</span> <span class="p">[],</span> <span class="n">rfunc</span><span class="p">,</span> <span class="n">newTFunc</span><span class="p">,</span> <span class="n">newHop</span><span class="p">,</span> <span class="n">bv</span><span class="p">,</span> <span class="p">[],</span> <span class="s2">&quot;travel time history&quot;</span><span class="p">)</span>
        <span class="n">hopRanges</span> <span class="o">=</span> <span class="p">[((</span><span class="mi">0</span><span class="p">,</span> <span class="n">numHops</span><span class="p">),</span> <span class="n">hop</span><span class="p">),</span> <span class="p">((</span><span class="n">numHops</span><span class="p">,</span> <span class="n">numHops</span> <span class="o">+</span> <span class="n">numHops2</span><span class="p">),</span> <span class="n">newHop</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timeActionStamp</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">TravelData</span><span class="p">(</span><span class="n">idn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeActionStamp</span><span class="p">,</span> <span class="n">pointData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">allPoints</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">allPoints2</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">durationData</span> <span class="o">=</span> <span class="n">dur</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dur2</span><span class="p">,</span>\
            <span class="n">velocityData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">baselineVelocity1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">baselineVelocity2</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">hopRanges</span> <span class="o">=</span> <span class="n">hopRanges</span><span class="p">),</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="n">stat</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ceil</span>

<span class="sd">    arguments:</span>
<span class="sd">    - rfunc: continue_travelling termination</span>
<span class="sd">    - tfunc: time threshold termination</span>

<span class="sd">    return:</span>
<span class="sd">    - (point)::2d-tuple</span>
<span class="sd">    - (all points)::(float | list(floats))</span>
<span class="sd">    - (duration)::(float | list(floats))</span>
<span class="sd">    - (velocity)::(float | list(floats))</span>
<span class="sd">    - (number of hops)::float</span>
<span class="sd">    - (halt restriction)::bool</span>
<span class="sd">    - (at end of poly.)::bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.run_travel_loop"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.run_travel_loop">[docs]</a>    <span class="k">def</span> <span class="nf">run_travel_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prevPoint</span><span class="p">,</span> <span class="n">allPoints</span><span class="p">,</span> <span class="n">rfunc</span><span class="p">,</span> <span class="n">tfunc</span><span class="p">,</span> <span class="n">hop</span><span class="p">,</span> <span class="n">baselineVelocity</span><span class="p">:</span><span class="nb">float</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span><span class="nb">list</span><span class="p">,</span> <span class="n">returnType</span><span class="p">:</span><span class="nb">str</span><span class="p">):</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">numHops</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">velocities</span> <span class="o">=</span> <span class="p">[</span><span class="n">baselineVelocity</span><span class="p">]</span>

        <span class="n">point</span> <span class="o">=</span> <span class="n">prevPoint</span>
        <span class="n">bFunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="ow">and</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">endByTFunc</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">haltRestricted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">ldx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">bFunc</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="p">(</span><span class="n">prevPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">hop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">hop</span><span class="p">))</span>
            <span class="n">ld0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>
            <span class="n">duration2</span><span class="p">,</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="n">distance2</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="n">durSat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">one_hop_for_travel_info</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">prevPoint</span><span class="p">,</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">rfunc</span><span class="p">,</span> <span class="n">tfunc</span><span class="p">,</span> <span class="n">returnType</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">haltRestricted</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">duration</span> <span class="o">=</span> <span class="n">duration2</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">distance2</span>

            <span class="n">allPoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="n">velocities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">baselineVelocity</span><span class="p">)</span>
            <span class="n">numHops</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">tfunc</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">duration</span><span class="p">)):</span>
                <span class="n">endByTFunc</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="n">prevPoint</span> <span class="o">=</span> <span class="n">point</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">allPoints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">sum</span><span class="p">(</span><span class="n">duration</span><span class="p">),</span> <span class="n">baselineVelocity</span><span class="p">,</span> <span class="n">numHops</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="ow">not</span> <span class="n">endByTFunc</span><span class="p">)</span>\
            <span class="k">if</span> <span class="n">returnType</span> <span class="o">==</span> <span class="s2">&quot;travel time&quot;</span> <span class="k">else</span> <span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">allPoints</span><span class="p">),</span> <span class="n">duration</span><span class="p">,</span> <span class="n">velocities</span><span class="p">,</span> <span class="n">numHops</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="ow">not</span> <span class="n">endByTFunc</span><span class="p">)</span></div>

    <span class="c1"># TODO: refactor this and replace above</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    return:</span>
<span class="sd">    - (duration)::(float | list(floats))</span>
<span class="sd">    - (velocity)::float</span>
<span class="sd">    - (distance travelled)::float</span>
<span class="sd">    - (negative halt restriction)::bool</span>
<span class="sd">    - (duration satisfied)::bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.one_hop_for_travel_info"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.one_hop_for_travel_info">[docs]</a>    <span class="k">def</span> <span class="nf">one_hop_for_travel_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">prevPoint</span><span class="p">,</span> <span class="n">previousVelocity</span><span class="p">,</span> <span class="n">prevTravelTime</span><span class="p">,</span> <span class="n">distanceTravelled</span><span class="p">,</span> <span class="n">rfunc</span><span class="p">,</span> <span class="n">tfunc</span><span class="p">,</span> <span class="n">returnType</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">returnType</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;travel time history&quot;</span><span class="p">,</span> <span class="s2">&quot;travel time&quot;</span><span class="p">),</span> <span class="s2">&quot;invalid return type&quot;</span>

        <span class="n">velocity</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_and_duration_between_points_by_angle_effect</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">previousVelocity</span><span class="p">)</span>

        <span class="c1"># not able to travel</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stat</span><span class="p">:</span>
            <span class="n">haltRestricted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ? negative halt restriction</span>
            <span class="n">haltRestricted</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">rfunc</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">haltRestricted</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">prevTravelTime</span><span class="p">),</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">distanceTravelled</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">if</span> <span class="n">returnType</span> <span class="o">==</span> <span class="s2">&quot;travel time&quot;</span> <span class="k">else</span>\
                <span class="p">(</span><span class="n">prevTravelTime</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">distanceTravelled</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">prevTravelTime</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">distanceTravelled</span> <span class="o">+=</span> <span class="n">point_distance</span><span class="p">(</span><span class="n">prevPoint</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>

        <span class="n">durSat</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">tfunc</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">prevTravelTime</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">prevTravelTime</span><span class="p">),</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">distanceTravelled</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="n">durSat</span><span class="p">)</span> <span class="k">if</span> <span class="n">returnType</span> <span class="o">==</span> <span class="s2">&quot;travel time&quot;</span>\
            <span class="k">else</span> <span class="p">(</span><span class="n">prevTravelTime</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">distanceTravelled</span><span class="p">,</span> <span class="n">haltRestricted</span><span class="p">,</span> <span class="n">durSat</span><span class="p">)</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    # TODO: can be used for agent decision input by query</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.continue_travelling"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.continue_travelling">[docs]</a>    <span class="k">def</span> <span class="nf">continue_travelling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">travelTime</span><span class="p">,</span> <span class="n">travelHistory</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">query</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">query</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;query mode needs to be implemented.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">travelTime</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span></div>

    <span class="c1">################################## START: estimation methods</span>

    <span class="c1">################################## END: estimation methods</span>

    <span class="c1"># TODO: caution, does not check args. start and end</span>
<div class="viewcode-block" id="LagrangePolySolver.y_extremes_in_xrange"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.y_extremes_in_xrange">[docs]</a>    <span class="k">def</span> <span class="nf">y_extremes_in_xrange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">hopIncrement</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">hopIncrement</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;invalid hop increment&quot;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span><span class="n">start</span>

        <span class="n">ysMin</span><span class="p">,</span> <span class="n">ysMax</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="n">ysMax</span><span class="p">:</span>
                <span class="n">ysMax</span> <span class="o">=</span> <span class="n">y</span>

            <span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">ysMin</span><span class="p">:</span>
                <span class="n">ysMin</span> <span class="o">=</span> <span class="n">y</span>

            <span class="n">start</span> <span class="o">+=</span> <span class="n">hopIncrement</span>

        <span class="k">return</span> <span class="n">ysMin</span><span class="p">,</span> <span class="n">ysMax</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    arguments:</span>
<span class="sd">    - refinement: float, [0,1] specifies the degree to partition the polynomial x-range.</span>
<span class="sd">    - totalArea: 2 x 2 np.array</span>
<span class="sd">    - radius: int, direction up and down from every point of consideration in polynomial.</span>
<span class="sd">    - forward: bool, specifies forward or backward direction for x-range.</span>

<span class="sd">    return:</span>
<span class="sd">    - list(area)</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.capture_polynomial_as_disqualifying_areas"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.capture_polynomial_as_disqualifying_areas">[docs]</a>    <span class="k">def</span> <span class="nf">capture_polynomial_as_disqualifying_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">refinement</span><span class="p">,</span> <span class="n">totalArea</span><span class="p">,</span> <span class="n">radius</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">forward</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">)</span> <span class="o">*</span> <span class="n">refinement</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="k">if</span> <span class="n">forward</span> <span class="k">else</span> <span class="n">lps</span><span class="o">.</span><span class="n">maximum</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">forward</span><span class="p">:</span> <span class="n">q</span> <span class="o">=</span> <span class="o">-</span><span class="n">q</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="ow">and</span> <span class="n">s</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">q</span>

            <span class="k">if</span> <span class="n">forward</span> <span class="ow">and</span> <span class="n">e</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">forward</span> <span class="ow">and</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">:</span>
                <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimum</span>

            <span class="n">yMin</span><span class="p">,</span> <span class="n">yMax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_extremes_in_xrange</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">yMin</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="ow">or</span> <span class="n">yMax</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;could not capture polynomial.&quot;</span><span class="p">)</span>

            <span class="c1"># form the four corners to an area</span>
            <span class="n">minPoint</span><span class="p">,</span> <span class="n">maxPoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">min</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">),</span> <span class="n">yMin</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">e</span><span class="p">),</span> <span class="n">yMax</span><span class="p">])</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">minPoint</span><span class="p">,</span> <span class="n">maxPoint</span><span class="p">])</span>
            <span class="n">areas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">area</span><span class="p">)</span>

            <span class="c1"># update</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">areas</span></div>

    <span class="c1">##### START: repr methods</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.form_point_sequence"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.form_point_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">form_point_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hopIncrement</span> <span class="o">=</span> <span class="n">DEFAULT_TRAVELLING_HOP</span><span class="p">,</span> <span class="n">capture</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">hopIncrement</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;hop increment has to be +&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">reverse</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span>
        <span class="n">hopIncrement</span> <span class="o">=</span> <span class="o">-</span><span class="n">hopIncrement</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">hopIncrement</span>
        <span class="n">tFunc</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="n">allPoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">tFunc</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_lagrange_basis</span><span class="p">(</span><span class="n">start</span><span class="p">)]</span>
            <span class="n">allPoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">hopIncrement</span>

        <span class="n">allPoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">allPoints</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">capture</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">allPoints</span>
        <span class="k">return</span> <span class="n">allPoints</span></div>

<div class="viewcode-block" id="LagrangePolySolver.poly_to_velocity_duration_measures_in_hop_iteration"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.poly_to_velocity_duration_measures_in_hop_iteration">[docs]</a>    <span class="k">def</span> <span class="nf">poly_to_velocity_duration_measures_in_hop_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">reverse</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">hopIncrement</span> <span class="o">=</span> <span class="n">DEFAULT_TRAVELLING_HOP</span><span class="p">):</span>
        <span class="c1"># collect velocity data</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">form_point_sequence</span><span class="p">(</span><span class="n">reverse</span><span class="p">,</span> <span class="n">hopIncrement</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">velocityData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durationData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">velocity</span><span class="p">,</span> <span class="n">stat</span><span class="p">,</span> <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity_and_duration_between_points_by_angle_effect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">velocity</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">velocityData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">velocity</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">durationData</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span>

            <span class="c1"># last element of data is no travel</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">stat</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
                <span class="k">break</span></div>

<div class="viewcode-block" id="LagrangePolySolver.poly_to_travel_data"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.poly_to_travel_data">[docs]</a>    <span class="k">def</span> <span class="nf">poly_to_travel_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">travelDataIdn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">form_point_sequence</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poly_to_velocity_duration_measures_in_hop_iteration</span><span class="p">(</span><span class="n">velocity</span><span class="p">)</span>
        <span class="n">hopRanges</span> <span class="o">=</span> <span class="p">[((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocityData</span><span class="p">)),</span> <span class="n">DEFAULT_TRAVELLING_HOP</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allTravelData</span> <span class="o">=</span> <span class="n">TravelData</span><span class="p">(</span><span class="n">travelDataIdn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">durationData</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocityData</span><span class="p">,</span> <span class="n">hopRanges</span><span class="p">,</span> <span class="n">velocity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allTravelData</span><span class="o">.</span><span class="n">velocity_to_pointwise_acceleration_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="LagrangePolySolver.clear_travel_data_variables"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.clear_travel_data_variables">[docs]</a>    <span class="k">def</span> <span class="nf">clear_travel_data_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">velocityData</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">durationData</span> <span class="o">=</span> <span class="p">[]</span></div>

    <span class="c1"># TODO: test this.</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.intersection_with_line"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.intersection_with_line">[docs]</a>    <span class="k">def</span> <span class="nf">intersection_with_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vfs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector_form_solution</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_vector_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">-=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">slope</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">yint</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">)</span> <span class="c1">#opt.newton(f, (self.maximum - self.minumum) / 2)</span>
            <span class="k">return</span> <span class="n">r1</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="LagrangePolySolver.intersection_with_line_v2"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.intersection_with_line_v2">[docs]</a>    <span class="k">def</span> <span class="nf">intersection_with_line_v2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">line</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vfs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vector_form_solution</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_by_vector_form</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">-=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">slope</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">line</span><span class="o">.</span><span class="n">yint</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="c1"># center self along opposing ends</span>
        <span class="n">lps2</span><span class="p">,</span><span class="n">mid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_by_endpoints</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">move_line_by_axis_shifts</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">mid</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lps2</span><span class="o">.</span><span class="n">intersection_with_line</span><span class="p">(</span><span class="n">l2</span><span class="p">)</span></div>

    <span class="c1">############################################################</span>

    <span class="c1"># TODO: method will replace above.</span>
    <span class="c1"># TODO: wrong.</span>
<div class="viewcode-block" id="LagrangePolySolver.center_axis_at_zero"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.center_axis_at_zero">[docs]</a>    <span class="k">def</span> <span class="nf">center_axis_at_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;invalid axis </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mini</span><span class="p">,</span><span class="n">maxi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mini</span><span class="p">,</span> <span class="n">maxi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_extremes_in_xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minumum</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maximum</span><span class="p">,</span> <span class="n">hopIncrement</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">)</span>

       <span class="c1"># get center</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxi</span> <span class="o">-</span> <span class="n">mini</span> <span class="p">)</span> <span class="o">/</span>  <span class="mf">2.0</span>
        <span class="n">dest</span> <span class="o">=</span> <span class="o">-</span><span class="n">mid</span>
        <span class="n">reloc</span> <span class="o">=</span> <span class="o">-</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mini</span> <span class="o">-</span> <span class="n">dest</span><span class="p">)</span>
        <span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">newData</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">newData</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reloc</span>
        <span class="k">return</span> <span class="n">LagrangePolySolver</span><span class="p">(</span><span class="n">newData</span><span class="p">),</span> <span class="n">reloc</span></div>

<div class="viewcode-block" id="LagrangePolySolver.center_at_zero"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.center_at_zero">[docs]</a>    <span class="k">def</span> <span class="nf">center_at_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">q</span><span class="p">,</span><span class="n">xs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_axis_at_zero</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">q2</span><span class="p">,</span><span class="n">ys</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">center_axis_at_zero</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">q2</span><span class="p">,</span><span class="n">xs</span><span class="p">,</span><span class="n">ys</span></div>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    centers endpoints along axis</span>
<span class="sd">    0 -&gt; balanced along y-axis</span>
<span class="sd">    1 -&gt; balanced along x-axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="LagrangePolySolver.center_by_endpoints"><a class="viewcode-back" href="../../morebs2.html#morebs2.poly_interpolation.LagrangePolySolver.center_by_endpoints">[docs]</a>    <span class="k">def</span> <span class="nf">center_by_endpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;invalid axis&quot;</span>

        <span class="c1"># calc. midpoint</span>
        <span class="c1"># set midpoint as 0 for axis and shift all other points</span>
        <span class="c1">#       by - midpoint</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">axis</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">mid</span>
        <span class="k">return</span> <span class="n">LagrangePolySolver</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="o">-</span><span class="n">mid</span></div></div>

    <span class="c1">##### END: repr methods</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">morebs</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">morebs2</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, Richard Pham.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>